ANALYSIS:
https://www.youtube.com/playlist?list=PLBf0hzazHTGMSlOI2HZGc08ePwut6A2Io

PE FILE STRUCTURE:
https://www.youtube.com/watch?v=SzOhG-aUUJs&ab_channel=7Tech


STATIC ANALYISIS:

It is the process of analyzing malware binary without executing it
The objective is to extract useful information from the malware , this will help us get an idea
of the type of malware and what the malware can do. This information is useful for future analysis
as it will allows us to efficientyl analyze the sample going forward.

Identifying the file type - target OS, architecture and format (dll, exe, etc.)
Identifying the malware - generatating a hash of the malware, this will give the malware
a unique identifier. Using the hash to see if anyone else has analyzed the malware.
String give us an idea glimpse of what the malware can do.
Packing and obfuscation are techniques used to prevent detection. Unpacking or deobfuscating can revel
additional information.
PE Headers revelas a lot of information on the malware functionality.

IDENTIFYING THE FILE TYPE:

Idetifying the file type is extremly importart as it helps us identify the target OS
and the corresponding architecture

An example of a Windows executable file is the PE (Portable Executable)
A PE could be in form of .exe, .dll, etc.
TO accurately inderify a file type we need to analyze the file signature. This is to avoid
false positives caused by the use of double extensions.
The file signature exists on the file header.
The file signature for PE files are represented by hexadecimal values of 4D 5A or MZ in the first 2 bytes (0-1)/
PE programos also have te notice "This program cannot be run in DOS mode"
The PE header begins at hex 50 45.

NOTE: Attackers may use archiving/packing to evade signature based indetification.

TOOLS we will be using
- HxD - Hex editor
- Exeinfo PE - Retrieves the windows PE header information. It also detects if the executable has been packed and detects
the peaker version and how to unpack it
- Pestudio
- CFF explorer


MALWARE HASHING:
This is process of generating cryptographic hashes for the file content of the target malware. We are hashing the malware file
The hashing algorithms used in malware indentification are:
 - MD5
 - SHA - 1
 - SHA - 256

The hashing process gives us a unique digest known as a figerprint.
This means we can create unique fingerprints for malware samples. 
 
WHY HASH:
- For accurate indetification of malware samples rather than using file name for malware. Hashes are unique.
- Hashes are used to indetify malware on malware analysis sites (Virus Total).
- Hashes can be used to search for any previous detections or for checking online if the sample has been
  analyzed by other researchers.

TOOLS:
 - hashmyfiles
 - hashcalc


ANALYZING STRINGS
String analysis is the process of extracting readable characters and words from the malware. 
It can give us valuable information about the malware functionality.
Malware will usually contain useful strings and other random strings also known as garbage strings
Strings are in ASCII(128 characters) and Unicode (128k characters) format. 
We need to specify the type of strings we want to extract during analysis.
As ome tools only extract ASCII. 
THe types of strings we are looking for are
 - File names
 - URL (Domains the malware connects to)
 - IP adresses
 - Registry keys

Attacker may also include fake strings to disrupt our analysis.
NOTE: Strings give us a glimpse of what the malware can do. 

TOOLS WE WILL USE:
 - Strings command line utility
 - Shell extensions
 - Pestudio
 - peid

Strings CMD
 -a ASCII only serch
 -b Bytes of file to scan
 -f File offset at which to start scanning
 -o Print offset in file string was located
 -n Minimum string length (default is 3)
 -s Recurse subdirectories
 -u Unicode-only search 

Minimum  string lenght is very important as it will allow us to sift through the random garbage strings.
All in the reference to the fact that usually for ASCII only you usually have 8 characters to work with
The range will be typically between 4-6-8. ...

PACKERS

A packer is a tool that is used to compress the content the malware. Attackers will use packers to obfuscate
the content of the malware this makes it difficult to analyze strings.
Packers compress an executable and when executed the packerd executable will be decompressed. This allows us
to analyze the original unpacked executable.

TOOLS
 - UPX
 - EXEinfo PE


PE HEADER

 - The PE header contains the information the OS requires to run the executable.
 - This informtion is very useful as it can give us more information about the functionality of the malware and how
   the malware interacts with OS.

Why is the PE header important:
 1. It contains all the importan and necessary information required by the OS to execute te executable
 2. It has information that specifies where the executable needs to be loaded into memory.
 3. There are libraries that the executable requires to bel loaded (dll).
 4. It specifies where the execution begins. 

PE HEADER STRUCTURE
--------------------------------------------------------------------------------------------------------
MZ Header / DOS Header     | Defines the file as an exectuable binary                                  |
--------------------------------------------------------------------------------------------------------
DOS Stub                   | Prints a message when run in DOS (for compatibility)                      |
--------------------------------------------------------------------------------------------------------
PE File Header (Signature) | Defines the executable as a PE                                            |
--------------------------------------------------------------------------------------------------------
Image Optional Header      | Important info about the executable like subsystem adn entry point        |
--------------------------------------------------------------------------------------------------------
Sections Table             | Instructions on how to load the exectuable into memory                    |
--------------------------------------------------------------------------------------------------------
Data Directories           | Data dir entry specifies the size and relative virtual address of the dir |
--------------------------------------------------------------------------------------------------------
Sections                   | Exectuable section of code and data used by the executable                |
--------------------------------------------------------------------------------------------------------

PE Sections
--------------------------------------------------
Section Name | Function                          |
--------------------------------------------------
.code/ .text | Exectuable code/entry point       |
--------------------------------------------------
.data        | Stores Data (R/W)                 |
--------------------------------------------------
.rdata       | Stores Data (Read Only)           |
--------------------------------------------------
.idata       | Stores The Import Table           |
--------------------------------------------------
.edata       | Stores Export Data                |
--------------------------------------------------
.rsrc        | Stores Resources (Strings, icons) |
--------------------------------------------------
.reloc       | Relocation iformation             |
--------------------------------------------------
.debug       | Debug inforamtion                 |
--------------------------------------------------
Analyzing the PE Header

 - The PE Header contais info that OS requires to run exectuabel
 - In static analysis we are lookking for information about the executable taht can give us a glimpse of it's 
   functionality and origin.

Information we are interested in:
 1. Compiler stamp - when and where the malware was compiled
 2. Subsystem - what subsystem is being used (GUI, etc.)
 3. Sections - is the executabel packed and are there any inconsistent permissions.
 4. Libraries and Imports - What libs and imports are being used and what information do they give us about the functionality


TOOLS
 - Pestudio - the most efficient tool for static analysis

 indicators
 dos-header
 dos-stub
 file-header
 optional-header
 directories
 sections
 libraries
 imports
 exports
 tls-callbacks
 resources
 strings
 debug
 manifest
 version
 certificate
 overlay

INDICATORS
 - ignores code integrity
 - ignores cookies on the stack (GS)
 - ignores Address Space Layout Randomization (ASLR)
 - ignores Data Execution Prevention (DEP)
 - does not contain a digital Certificate
 - has blacklisted strings
 - file-ratio of all sections reaches 98.53%
 - file is resource-less
 - imports 33 blacklisted functions
 - online scoring service is not reachable
 - file references (8) Windows built-in privileges
 - file has URL pattern references
 - file has blacklisted (4) library
 - dos-stub is missing 

FILE HEADER
 - signature
 - machine
 - sections
 - compiler stamp
 - pointer symbol table
 - number of symbols
 - size of optional header
 - processor - 32 bit
 - relocation stripped
 - larger address aware
 - unicprocessor
 - system image
 - dynamic link library
 - debug stripped
 - media run from swap
 - netwrok run from swap 

RESOURCES
Examining the resources section (.rsrc)
The resources section contains all the necessary files and information that are used/required by the executable.
For example: icons, dialogs, etc.

Why it is important
 - Attackers can utilize the resources sections to store more malicious files and data like payloads, droppers, config info etc.
 - The resource section is also useful as it may contain information about the origin of the malware.

TOOLS
 - Pestudio
 - Resource Hacker

MALWARE CLASSIFICATION AND IDENTIFICATION

Malware classification is the process of classifying malware samples based on shared characteristics
with previously analyzed samples. An example of these charachteristics are strings and binary code.

What is wrong with hash-based indentification/classification ?
 - The content of the samples are changed by attackers to evade hash based identification/classification
 - Cryptographic hashing is only accurate if the data/content of the sample remain the same. If just 
   one line of code is changed the hash changes.

NOTE: The attacker may only change a small portion of sample, but the functionality of the malware remains the same.  
      While the hash changes completely. For example many attackers will usually plant random data/strings to change teh hash
      and avoid hash-based detection/identification (garbage strings)

What the point ?
Hash based signature idetification/detection is inaccurate and should not be relied upon for accurate classification of samples.
This is where YARA comes into play.

WHAT IS YARA ?
YARA is an malware indetification and classification tool that works by matching patterns accross various malware samples.

What can we do with YARA
 - Signature identification based on a particular signatures.
 - We can generate rules that identify particular signatures that can then be used to detect future similar infections (AV's)

YARA rules are used to identify samples based on a specific strings or binary data
Structure of a YARA rule

rule <rule_name>
{
meta:
	description = 'sample yara rule'
strings:
	$a = 'example1'
	$b = 'example2'

condition:
	($a or $b)
}

rule creds_rule
{
meta:
	description = 'simple yara rule to detect russian credential harvesters'

strings:
	$a = 'http://ruzzia.ru/gate.php'
	$b = 'http://russia.ru/gate.php'
 	$c = 'http://zapoys.ru/gate.php'
	$m = {4D 5A}
	$p = "HTPP"
codition:
	($a or $b or $c and $m or $p)
}


save this file as creds.yara
yara32 --help

-t print rules tagged as TAG
-i rules named IDENTIFIER
-c number of matches
-n negate (not satisfied rules)
-D module data
-g tags
-m metadata
-s matching strings
-L length of matched strings
-e rules namespace
-p specified NUMBER of threads to scan a directory
-l abort scanning after matching a NUMBER of rules
-d define external variable
-x pass FILE content as extra data to MODULE
-a abort scanning after the given number os SECONDS
-k set maximum stack size (default = 16384)
   set maximum number of strings per rule (default = 10000)
-r recursively search directories
-f fast matching mode
-w disable warnings/fail on warnings
-v show version information
-h show help

 
