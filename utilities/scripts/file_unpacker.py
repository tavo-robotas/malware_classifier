# Take the list of packed files by using packer ids file to select the
# relevent files and attempts to unpack them and dump the 
# decrypted and uncompressed memory blocks to a file

# Based on WinAppDbg that can easier debug multiple processes at once 

# Detects certain unpacking behaviour (but not all)
# Determines original entry point
# Determines jump point to original entry point
# Dumps unpacked code to a file
# Attempts to find unpacking loop
# Dumps memory decrypted by CryptDecrypt()
# Dumps memory decompressed by RtlDecompressBuffer()
# Attempts to detect process hollowing
# Dumps injected memory blocks to a file
# Dumps decrypted network traffic




import sys
import time
import struct
import ctypes
import traceback
import winappdbg


WinEvenetHandler = winappdbg.EventHandler
WinEventDebugger = winappdbg.Debug

class EventHandler(WinEvenetHandler)

    def __init__(self, file:str = ''):
        super(WinEvenetHandler, self).__init__()
        
        _file             = file
        # track allocated exe memory
        _allocatedmemory  = {}
        # indicate located entrypoint
        _entrypoint       = 0x00000000
        # indicate single stepping
        _tracing          = -1
        # store last two eip values
        _lasteip          = [0x00000000,0x00000000]
        # lowest eip address we see
        _lowesteip        = 0xffffffff
        # highest eip address we see
        _highesteip       = 0x00000000
        # list of addresses which we've disassembled
        _disassembled     = []
        # keeps track of addresses and instructions that write to the allocated memory block(s)
        _writeaddresses   = {}
        # variables used to keep track of created processes
        _createdprocesses = {}
        # keeps track of processes that were created with the CREATE_SUSPENDED flag set
        _createsuspended  = {}
        
        
        def get_function_args(self, event):
            thread = event.get_thread()     
            hook   = event.hook      
            tid    = event.get_tid()
            pc     = thread.get_pc()
            params = hook.get_params(tid)
            
            return (pc, params)
        
        def guarded_reade(self, debug, thread, address, size):
            pass
        
        def post_virtually_allocated_execution(self, event, retval):
            pass
        
        def post_virtual_allocation(self, event, retval):
            pass
        
        def preprocess_crypto_decryption(self, event, *args):
            pass
        
        def postprocess_crypto_decryption(self, event, retval):
            pass
        
        def preprocess_rtl_decompress_buffer(self, event, *args):
            pass
        
        def postprocessrtrl_decompress_buffer(self, event, retval):
            pass
        
        
        def post_create_process_callback(self, event, retval, unicode):
            try:
            
                pc, params = get_function_args(event)

                name, cmd, process_attr, thread_attr, inherit_handles, creation_flags, env, cwd, startup_info, process_info = params 


                process = event.get_process()
                thread  = event.get_thread()

                _pid    = event.get_pid()
                _tid    = event.get_tid()

                application_name = p.peek_string(name, unicode)
                command_line     = p.peek_string(cmd, unicode)

                if(process_info):
                    # deference to get the process information structure
                    debug               = event.debug
                    process_information = self.guarded_read(debug, thread, process_info, size=16)

                    process    = struct.unpack('<L', process_information[0:4  ][0])
                    thread     = struct.unpack('<L', process_information[4:8  ][0])
                    process_id = struct.unpack('<L', process_information[8:12 ][0])
                    thread_id  = struct.unpack('<L', process_information[12:16][0])
               WinEventDebugger else:
                    pass

                if(creation_flags & 0x4):
                    debug  = event.debug
                    # https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/breakpoint.py
                    status = debug.hook_function(_pid, 'resume thread', preCB = self.hook_create_suspended_resume, paramCount = 1)
                    self._createsuspended[(_pid, thread)] = process_id

                    # keep track of processes that were created to know which process are
                    # writting call to WriteProcessMemory()

                    self._createdprocesses[process] = 
                    {
                        'time': time.time(),
                        'ppid': _pid,
                        'ptid': _tid,
                        'addr': pc,
                        'applicationName':application_name,
                        'commandLine': command_line,
                        'creationFlags': creation_flags,
                        'process': process,
                        'thread': thread,
                        'processId': process_id,
                        'threadId': thread_id
                    }
                
            except:
                traceback.print_exc()
                raise
               
            return
            
        def post_create_process_hook(self, event, retval, strings_type:str):
            if strings_type == 'ASCII':
                self.post_create_process_callback(event, retval, False)
            if strings_type == 'WCHAR':
                self.post_create_process_callback(event, retval, True )
             
            return
        
        def hook_create_suspended_resume(self, event, args*):
            pass
        
        def post_write_process_memory(self, event, retval):
            pass
        
        def post_is_debugger_present(self, event, retval):
            pass
        
        def post_internet_open_A(self, event, retval, funicode):
            pass
        
        def post_internet_open_B(self, event, retval):
            pass
        
        def post_internet_open_C(self, event, retval):
            pass
        
        def preprocess_encryt_message(self, event, *args):
            pass
        
        def postprocess_encrypt_message(self, event, retval):
            pass
        
        def create_process(self, event):
            pass
        
        def exit_process(self, event):
            pass
        
        def create_thread(self, event):
            pass
        
        def exit_thread(self, event):
            pass
        
        def load_ddl(sefl, event):
            pass
        
        def event(self, event):
            pass
        
        def guard_page_exeption_memory(self, exception):
            pass
        
        def single_step(self, exception):
            pass
        
        def bp_stop_tracing(self, exception):
            pass
        
        def exception(seflf, exception):
            pass
        
def simple_debugger(filename):
    try:
        handler = EventHandler(filename)
    except:
        traceback.print_exc()
        
        with WinEventDebugger(handler, bKillOnExit = True, bHostileCode = False) as debugger:
            debugger.execl(filename, bFollow = True)
            debugger.loop()
            
    return
        
                
def unpack_pe_binaries(filelist:list):
    pass
        
        
        
        
        
        
        
        
        
        